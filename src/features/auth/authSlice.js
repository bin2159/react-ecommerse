import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'
import { checkAuth, createUser, loginUser, signOut } from './authAPI'

const initialState = {
  loggedInUserToken: null,
  status: 'idle',
  error: null,
  userChecked:null
}

export const createUserAsync = createAsyncThunk(
  'user/createUser',
  async (userInfo, { rejectWithValue }) => {
    try {
      const response = await createUser(userInfo)
      return response.data
    } catch (error) {
      console.log(error)
      return rejectWithValue(error.data)
    }
  }
)
export const loginUserAsync = createAsyncThunk(
  'user/loginUser',
  async (loginInfo, { rejectWithValue }) => {
    try {
      const response = await loginUser(loginInfo)
      return response.data
    } catch (error) {
      return rejectWithValue(error)
    }
  }
)
export const checkAuthAsync = createAsyncThunk(
  'user/checkUser',
  async () => {
    try {
      const response = await checkAuth()
      return response.data
    } catch (error) {
      console.log(error)
    }
  }
)
export const signOutAsync = createAsyncThunk('user/signOut', async (userId) => {
  const response = await signOut(userId)
  return response.data
})

export const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    resetError: (state) => {
      state.error = null
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(createUserAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(createUserAsync.fulfilled, (state, action) => {
        state.status = 'idle'
        state.loggedInUserToken = action.payload
      })
      .addCase(createUserAsync.rejected, (state, action) => {
        state.status = 'idle'
        state.error = action.payload
      })
      .addCase(loginUserAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(loginUserAsync.fulfilled, (state, action) => {
        state.status = 'idle'
        state.loggedInUserToken = action.payload
      })
      .addCase(loginUserAsync.rejected, (state, action) => {
        state.status = 'idle'
        state.error = action.payload
      })
      .addCase(signOutAsync.pending, (state) => {
        state.status = 'loading'
      })
      .addCase(signOutAsync.fulfilled, (state, action) => {
        state.status = 'idle'
        state.loggedInUserToken = null
      })
      .addCase(checkAuthAsync.pending,(state)=>{
        state.status='loading'
      })
      .addCase(checkAuthAsync.fulfilled,(state,action)=>{
        state.status='idle'
        state.loggedInUserToken=action.payload
        state.userChecked=true
      })
      .addCase(checkAuthAsync.rejected,(state)=>{
        state.status='idle'
        state.userChecked=true
      })
  },
})

export const { resetError } = authSlice.actions

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.user.value)`
export const selectloggedInUser = (state) => state.auth.loggedInUserToken
export const selectError = (state) => state.auth.error
export const selectUserChecked=(state)=>state.auth.userChecked
export default authSlice.reducer
